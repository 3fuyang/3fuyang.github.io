import{j as s}from"./jsx-runtime-f0839969.js";const o="TS 中的函数重载",x="2022-09-12T22:06:00.000+00:00",c="zh",i="1min",l="/notes/overload-in-ts";function r(t){const e=Object.assign({nav:"nav",ol:"ol",li:"li",a:"a",h1:"h1",p:"p",strong:"strong",code:"code"},t.components);return s.exports.jsxs(s.exports.Fragment,{children:[s.exports.jsx(e.nav,{className:"toc",children:s.exports.jsx(e.ol,{className:"toc-level toc-level-1",children:s.exports.jsx(e.li,{className:"toc-item toc-item-h1",children:s.exports.jsx(e.a,{className:"toc-link toc-link-h1",href:"#ts-中的函数重载",children:"TS 中的函数重载"})})})}),`
`,s.exports.jsx(e.h1,{id:"ts-中的函数重载",children:"TS 中的函数重载"}),`
`,s.exports.jsxs(e.p,{children:["TypeScript 中的函数重载（Function Overload）较为特别，其允许的是",s.exports.jsx(e.strong,{children:"声明"}),"（Declaration）重载，而不是",s.exports.jsx(e.strong,{children:"实现"}),"（Implementation）重载。"]}),`
`,s.exports.jsxs(e.p,{children:["意即，不论在声明中对函数重载多少次，也仅允许有",s.exports.jsx(e.strong,{children:"唯一一个"}),"实现，且这种实现必须",s.exports.jsx(e.strong,{children:"兼容"}),"所有声明。"]}),`
`,s.exports.jsxs(e.p,{children:["这可以从各重载的",s.exports.jsx(e.strong,{children:"返回值"}),"必须",s.exports.jsx(e.strong,{children:"相同"}),`看出,
因为 JavaScript 的函数调用时的`,s.exports.jsx(e.strong,{children:"参数"}),"（arguments）处理就是粗暴的",s.exports.jsx(e.strong,{children:"数组传递"}),"，所以函数的",s.exports.jsx(e.strong,{children:"签名"}),"就完全由",s.exports.jsx(e.strong,{children:"返回值"}),"确定。"]}),`
`,s.exports.jsxs(e.p,{children:["所以 TS 中函数重载的意义主要在于，使 IDE 能够提供",s.exports.jsx(e.strong,{children:"函数重载"}),"这种思维模式的",s.exports.jsx(e.strong,{children:"代码提示"}),"。"]}),`
`,s.exports.jsxs(e.p,{children:["完全符合 TypeScript 作为 JavaScript 的",s.exports.jsx(e.strong,{children:"注释"}),"的角色，除了",s.exports.jsx(e.code,{children:"class"}),"和",s.exports.jsx(e.code,{children:"enum"}),"外不具备任何",s.exports.jsx(e.strong,{children:"运行时"}),"功能。"]})]})}function p(t={}){const{wrapper:e}=t.components||{};return e?s.exports.jsx(e,Object.assign({},t,{children:s.exports.jsx(r,t)})):r(t)}export{x as date,p as default,i as duration,c as lang,l as path,o as title};
