import fg from 'fast-glob'
import { writeFileSync } from 'node:fs'
import { resolve } from 'node:path'

const rawPaths = await fg(
  [
    'pages/**/*.mdx',
    'pages/**/*.tsx'
  ],
  {
    objectMode: true
  }
)

interface Page {
  name: string,
  path: string,
  element: string
}

type Route = Pick<Page, 'path'> & Partial<Pick<Page, 'element'>> & {
  caseSensitive: boolean
  children?: Route[]
}

let counter = 0
const imports: string[] = []

const pages: Page[] = rawPaths.map(({ path, name }) => {
  const plainName = /^index/.test(name) ? '/' : name.split('.')[0]
  const extName = /\.mdx$/.test(name) ? name : name.split('.')[0]
  const importName = `Page_${counter++}`

  imports.push(`import ${importName} from '../../${path.replace(name, extName)}'`)

  return {
    name,
    path: path.match(/pages\/(.*)/)![1],
    // relative to `src/routes`
    element: `@createElement(PostWrapper, { path: '${plainName}' }, createElement(${importName}))@`
  }
})

interface Dir {
  path: string
  container?: Pick<Route, 'caseSensitive' | 'path'> & Required<Pick<Route, 'children'>>
}

function transform(pages: Page[]) {
  const currDirs: Dir[] = []
  const result: Route[] = []

  for (const { name, path, element } of pages) {
    const pageDir = path.split(name)[0]
    const folders = pageDir.split('/')
    let matchedIndex = -1

    // 与当前路由栈从前往后进行匹配
    for (let i = 0; i < folders.length && i < currDirs.length; ++i) {
      // 当出现不匹配时，跳出循环
      if (folders[i] !== currDirs[i].path) {
        break
      }
      matchedIndex = i
    }

    // 从路由栈中匹配到了已有路由
    if (matchedIndex >= 0) {
      // 将路由栈匹配中不匹配的路由删除
      currDirs.splice(matchedIndex + 1)

      // 将新增的路由添加到当前路由栈中
      folders.slice(matchedIndex + 1).forEach((newFolder) => {
        // 栈顶父路由
        const parent = currDirs.at(-1)?.container,
          // 新父路由
          newParent: Dir['container'] = {
            caseSensitive: true,
            path: newFolder,
            children: []
          }

        // 与上层路由建立父子关系
        parent?.children?.push(newParent)
        // 新父路由进栈
        currDirs.push({
          path: newFolder,
          container: newParent
        })
      })
    }
    // 从路由栈中未匹配到任一路由
    else {
      // 清空路由栈
      // 注意：先将栈底路由加入到 result 中
      currDirs.length && result.push(currDirs[0].container!)
      currDirs.length = 0
      // 重新构建路由栈
      folders.forEach((newFolder) => {
        if (newFolder === '') return
        const newParent: Dir['container'] = {
          caseSensitive: true,
          path: newFolder,
          children: []
        }

        currDirs.length && currDirs.at(-1)?.container?.children?.push(newParent)

        currDirs.push({
          path: newFolder,
          container: newParent
        })
      })
    }

    const newLeaf = {
      caseSensitive: true,
      path: /index\.\w+/.test(name) ? '' : name.match(/^([^.]+)\./)![1],
      element
    }

    currDirs.length
      ? (currDirs.at(-1)?.container?.children?.push(newLeaf))
      : (result.push({ ...newLeaf, path: newLeaf.path === '' ? '/' : newLeaf.path }))
  }

  currDirs.length && result.push(currDirs[0].container!)

  return result
}

const result = transform(pages)

// serialize

const content =
  `/* Notice: This file is generated by scripts/auto-routes.ts */

import { createElement } from 'react'
import PostWrapper from '../components/PostWrapper'`
  + imports.reduce((prev, curr) => prev + curr + '\n', '\n')
  + `
const routes = ${JSON.stringify(result)}

export default routes
  `.replace(/"@[^@]+@"/g, (match) => match.slice(2, -2))

writeFileSync(
  resolve('src/models/routes.ts'),
  content,
  {
    encoding: 'utf8',
    flag: 'w'
  }
)
