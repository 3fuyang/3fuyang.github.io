---
title: JavaScript 的事件循环（Event Loop）
date: 2022-09-03T18:42:00.000+00:00
lang: zh
duration: 4min
path: /blog/js-event-loop
---

# JavaScript 的事件循环（Event Loop）

**参考资料**：
- [Tasks, microtasks, queues and schedules - JakeArchibald.com](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly)
- [浏览器事件循环机制_唐霜的博客 (tangshuang.net)](https://www.tangshuang.net/7617.html)

JavaScript 是一门**单线程同步**编程语言，任务只能在主线程上一个一个**串行**地执行。

为了让多类型的任务在主线程上有条不紊地执行，JavaScript 引入了**任务队列**（Task Queue）和**事件循环**（Event Loop）。

虽然 JS 为单线程，但一个页面（tab）是**多线程**的，其中最主要的是 JS 引擎线程（V8）、GUI 渲染引擎线程。

每一个线程有**自己的**事件循环，且**同源**的多个**窗口**之间**共享**一个事件循环，因此它们可以同步地通信。

一个事件循环有**多个**任务源（source），这些源维护它们内部任务的执行次序，但浏览器每次循环（每一次循环被称为一`Tick`）会**挑选一个源**，从中取出一个任务。这使得浏览器能优先考虑**性能敏感**的任务，比如用户输入。

**任务**是设置（scheduled）好的，因此浏览器能从其内部进入 JavaScript/DOM 域，以确保这些行为是顺序发生的。在任务之间，浏览器可能会进行渲染更新。

从一次鼠标点击中获取事件回调就需要设置一个任务，同样，解析 HTML、`setTimeout`也是。

**微任务**（Microtasks）一般是应该在当前执行的脚本完成后，立即发生的行为，它们可能有点**异步**，但不创建新的任务。

当执行栈中的任务执行完毕，没有其他的 JS 正在主线程运行时，微任务将被处理。在微任务中创建的微任务也会被添加到当前任务的**微任务队列**中。

> 注意：当引擎遇到一个微任务后，会在将其加入微任务队列后，**跳过**其整体表达式的执行。
>
> ``` javascript
> Promise.resolve()
> 	// microtask1
> 	.then(() => {
>     console.log('promise1')
> 	})
> 	// microtask2
>     .then(() => {
>         console.log('promise2')
>     })
> 
> console.log('end')
> ```
>
> 上述代码中，当引擎遇到`microtask1`时，将其加入微任务队列，但此时**不会扫描**到`microtask2`；在执行完脚本后，取出`microtask1`执行，此时才扫描到`microtask2`，将其加入微任务队列。

由于执行微任务可以引入新的微任务，且这些微任务都会在当前宏任务下执行完毕，所以微任务可能一直占用当前的引擎，**无限阻塞**接下来的宏任务。

<img src="/images/js-event-loop/warning.png" alt="warning" rel="noreferrer" className="invertable" />

## 什么会创建宏任务（macrotask）？

常见的：

+ 直接执行一个新的 JavaScript 程序或子程序时（比方说从控制台、一个`<script>`元素 / JS 文件中）。
+ 触发一个 UI 交互事件时，**事件的处理回调**（event handler callback）将加入宏任务队列。

> **注意：**
>
> + 由事件冒泡或捕获导致的多个事件处理回调属于**同一个**宏任务。
> + 在宏任务中，只要**执行栈**不为空，就无法开始执行微任务，要注意用**顶级函数调用**触发微任务的情况。

+ 当一个定时器（`setTimeout()`、`setInterval()`）到达时，其**回调**被加入到宏任务队列中。

不常见的：

+ Node.js API `setImmediate`的回调会加入到宏任务队列。

+ 负责 Worker 或 Window 之间通信的`portMessage`回调。
+ MessageChannel、I/O ...

## 什么会创建微任务（microtask）？

常见的：

+ Promise 对象用`then()`注册的回调。
+ `async/await`中的`await`语句（statement）。
+ `MutationObserver`的回调。

> **注意**：当前宏任务下有`pending`状态的`MutationObserver`回调时，**不会为其他`MutationObserver`回调再创建新的微任务**。
>
> <img alt="mid-execution" rel="noreferrer" src="/images/js-event-loop/mid-execution.png" />

不常见的：

+ Node.js 中的`process.nextTick()`的回调。