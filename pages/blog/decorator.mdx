---
title: Decorator
date: 2021-05-19T16:00:00.000+00:00
lang: zh
duration: 15min
---

# Decorator

[TypeScript Decorators](https://www.typescriptlang.org/docs/handbook/decorators.html)

## Introduction

**装饰器**(Decorator)提供一种为类声明和成员添加注释和元编程语法的方式，它本身是 JavaScript 的一项 stage 2 提案，也是 TypeScript 的一个实验性特性。

需要在 TSConfig 中开启该特性，`"experimentalDecorators": true`。

## Decorators

一个装饰器是一种**特殊的声明**，它可以添加到类声明、方法、访问器 (accessor) 、属性和参数上。

装饰器的形式是`@expression`，其中`expression`必须等价于一个**函数**，这个函数将在**运行时**使用被装饰的声明的信息被调用。

``` typescript
function sealed(target) {
    // do something with the declaration
}

@sealed
declare ...
```



## Decorator Factories

如果我们想要自定义一个装饰器如何作用于声明上，可以写一个**装饰器工厂**。装饰器工厂是一个返回在运行时被装饰器调用的 expression 的函数。

``` typescript
function color(value: string) {
    return (target) => {
        // 这个函数是装饰器
    }
}
```

## Decorator Composition

多个装饰器可以被应用到一个声明上。

``` typescript
@f
@g
x
```

它们等价于数学上的函数组合，即 *f(g(x))*。

因此，当评估单个声明上的多个装饰器时，会执行以下步骤：

1. 每个装饰器的 expression 被从上往下**评估** (evaluated，执行表达式，得出 *expression: function*) 。
2. 将结果作为函数从下往上调用。

``` typescript
function first () {
    console.log(`first(): factory evaluated`)
    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
        console.log(`first(): called`)
    }
}

function second () {
    console.log(`second(): factory evaluated`)
    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
        console.log(`second(): called`)
    }
}

class ExampleClass {
    @first()
    @second()
    method() {}
}

// output in the console
first(): factory evaluated
second(): factory evaluated
second(): called
first(): called
```

## Decorator Evaluation

装饰器如何应用到一个类内部各种声明，有明确的顺序：

1. 后跟方法、访问器或属性装饰器的参数装饰器应用于每个实例成员。
2. 后跟方法、访问器或属性装饰器的参数装饰器应用于每个**静态**成员。
3. 类装饰器应用于整个类。

## Class Decorator

类装饰器随后必须紧跟类声明，它被应用于该类的构造函数，并且可被用来观察、修改和替换一个类定义。

类装饰器不能被用于声明文件 (`.d.ts`) 中，也不能用于环境上下文 (ambient context) 中。

类装饰器的 expression 会在运行时被调用，类的构造函数会作为唯一的参数传递给 expression。

如果类装饰器有返回值，这个值将取代 (作为) 类声明中提供的构造函数的返回值。

> 注意：如果选择在类装饰器中返回一个新的构造函数，则需要注意维持原本的原型链。

``` typescript
@sealed
class BugReport {
    type = 'report'
    title: string
    
    constructor (t: string) {
        this.title = t
    }
}

function sealed (constructor: Function) {
    Object.seal(constructor)
    Object.seal(constructor.prototype)
}
```

在上面的例子中，`@sealed`执行时，会冻结构造函数和其原型，借此防止运行时，在该类上通过`BugReport.prototype`或在`BugReport`上定义属性的方式，添加或移除功能。该装饰器不能防止对`BugReport`派生的子类的修改。

下面的例子，展示了如何重载构造函数以**设置新的默认值**。

``` typescript
function reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
        reportingURL = 'http://www...'
    }
}

@reportableClassDecorator
class BugReport {
    type = 'report'
    title: string
    
    constructor (t: string) {
        this.title = t
    }
}

const bug = new BugReport('Needs dark mode')

// 装饰器并未修改TypeScript 类型
// 所以新增的 reportingURL 属性对于类型系统是未知的
bug.reportingURL
```

## Method Decorators

方法装饰器应该紧跟在方法声明前，它被应用在方法的属性描述符上，并且可用于观察、修改和替换方法的定义。同样，不能被用于声明文件或环境上下文。

方法装饰器的 expression 会在运行时被调用，它会被传递以下三个参数：

1. 静态成员的类的构造函数，或者实例成员的类的原型。
2. 成员的名称。
3. 成员的属性描述符 (*Property Descriptor*) 

> 注意：如果转译目标低于 ES5，那么属性描述符不可用 (`undefined`) 。

如果方法装饰器返回一个值，那它将被用作该方法的属性描述符。

``` typescript
class Greeter {
    greeting: string
    constructor (message: string) {
        this.greeting = message
    }
    
    // use a decorator factory to generate a decorator
    @enumerable(false)
    greet () {
        return `Hello, ${this.greeting}`
    }
}

function enumerable (value: boolean) {
    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
        descriptor.enumerable = value
    }
}
```

## Accessor Decorators

紧跟在访问器之前的访问器装饰器。访问器装饰器被应用到访问器的属性描述符上，可用来观察、修改和替换访问器的定义。

> 注意：TypeScript 不允许**同时装饰**一个成员的 **get** 和 **set** 访问器。但是，一个成员的所有装饰器都必须被应用于文件顺序的第一个访问器上。这是因为装饰器应用在属性描述符上，属性描述符同时结合了 get 和 set 访问器，而不是分别声明。

访问器装饰器的 expression 会被传入以下参数 (与成员装饰器相同) ：

1. 静态成员的类的构造函数，或者实例成员的类的原型。
2. 成员的名称。
3. 成员的属性描述符 (*Property Descriptor*) 

``` typescript
class Point {
    private _x: number
    private _y: number
    constructor (x: number, y: number) {
        this._x = x
        this._y = y
    }
    
    @configurable(false)
    get x () {
        return this._x
    }
    
    @configurable(false)
    get y () {
        return this._y
    }
}

function configurable (value: boolean) {
    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
        descriptor.configurable = value
    }
}
```

## Property Decorators

属性装饰器。定义同上，略。

属性装饰器的 expression 在运行时被调用，传入两个参数：

1. 静态成员的类的构造函数，或者实例成员的类的原型。
2. 成员的名称。

> 注意：属性描述符没有被提供为属性装饰器 expression 的参数，这是由于 TypeScript 中属性装饰器的初始化机制。目前在定义原型成员时没有描述实例属性的机制，也没有办法观察或修改属性的初始化。因此，属性装饰器只能用于观察已经被类声明了特定名称的属性。

我们可以使用这个信息来记录属性的元信息。

``` typescript
class Greeter {
	@format('Hello, %s')
    greeting: string
    
    constructor (message: string) {
        this.greeting = message
    }
    
    greet () {
        const formatString = getFormat(this, 'greeting')
        return formatString.replace('%s', this.greeting)
    }
}

// reflect-metadata library
import 'reflect-metadata'

const formatMetadataKey = Symbol('format')

function format (formatString: string) {
    return Reflect.metadata(formMetadataKey, formatString)
}

function getFormat (target: any, propertyKey: string) {
    return Reflect.getMetadata(formatMetadataKey, target, propertyKey)
}
```

## Parameter Decorators

参数装饰器紧跟参数声明。参数装饰器被应用到类构造函数或方法声明的函数上。同样，它不能被用于声明文件、重载或环境上下文中。

它的 expression 被传入下面三个参数：

1. 静态成员的类的构造函数，或者实例成员的类的原型。
2. 成员的名称。
3. 参数在函数的参数列表中的原始索引。

> 注意：参数装饰器只能被用于观察已在方法上声明的参数。

参数装饰器的返回值**被忽略**。

``` typescript
class BugReport {
    type = 'report'
    title: string
    
    constructor (t: string) {
        this.title = t
    }
    
    @validate
    print (@required verbose: boolean) {
        if (verbose) {
            return `type: ${this.type}\ntitle: ${this.title}`
        } else {
            return this.title
        }
    }
}

import 'reflect-metadata'
const requiredMetadataKey = Symbol('required')

function required (target: any, propertyKey: string | symbol, parameterIndex: number) {
    let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || []
    existingRequiredParameters.push(parameterIndex)
     Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey)
}

function validate (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
  let method = descriptor.value!
 
  descriptor.value = function () {
    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName)
    if (requiredParameters) {
      for (let parameterIndex of requiredParameters) {
        if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {
          throw new Error("Missing required argument.")
        }
      }
    }
    return method.apply(this, arguments)   
}
```

## Meta data

上面的一些例子使用了`reflect-metadata`库，它加入了对实验性特性metadata API 的 polyfill。该库还没有成为 ECMAScript 标准，但是一旦装饰器被证实纳入标准，那么这些拓展也会被提议纳入。

该库需要从 npm 上手动安装：

``` shell
npm i reflect-metadata
```

TypeScript 包括了为拥有装饰器的声明产生某些类型的元数据的实验性特性。为启用该特性，需要设置 TSConfig：

``` json
{
    "compilerOptions": {
        "emitDecoratorMetadata": true
    }
}
```

启用以后，只要`reflect-metadata`库被引入，额外的设计时 (design-time) 类型信息将会在运行时暴露 (expose) 。

``` typescript
import "reflect-metadata"
 
class Point {
  constructor (public x: number, public y: number) {}
}
 
class Line {
  private _start: Point
  private _end: Point
 
  @validate
  set start (value: Point) {
    this._start = value
  }
 
  get start () {
    return this._start
  }
 
  @validate
  set end (value: Point) {
    this._end = value
  }
 
  get end () {
    return this._end
  }
}
 
function validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {
  let set = descriptor.set!
  
  descriptor.set = function (value: T) {
    let type = Reflect.getMetadata("design:type", target, propertyKey)
 
    if (!(value instanceof type)) {
      throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`)
    }
 
    set.call(this, value)
  }
}
 
const line = new Line()
line.start = new Point(0, 0)
 
// @ts-ignore
// line.end = {}
 
// Fails at runtime with:
// > Invalid type, got object not Point
```

TypeScript 编译器会使用`@Reflect.metadata`装饰器注入设计时类型信息。用户可以认为其等价于下面的代码：

``` typescript
class Line {
    private _start: Point
    private _end: Point
    
    @validate
    @Reflect.metadata('design:type', Point)
    set start (value: Point) {
        this._start = value
    }
    
    get start () {
        return this._start
    }
    
    @validate
    @Reflect.metadata('design:type', Point)
    set end(value: Point) {
        this._end = value
    }
    get end() {
        return this._end
    }    
}
```
